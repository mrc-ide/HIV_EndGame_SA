#!/usr/bin/env Rscript
`%||%` <- function (x, y)
{
    if (is.null(x))
        y
    else x
}
clean_repos <- function (repos, cran = NULL)
{
    if (is.null(repos)) {
        return(c(CRAN = default_cran(cran)))
    }
    if (!("CRAN" %in% names(repos)) || repos[["CRAN"]] == "@CRAN@") {
        repos[["CRAN"]] <- default_cran(cran)
    }
    repos
}
conan_bootstrap <- function (path, upgrade = FALSE)
{
    dir.create(path, FALSE, TRUE)
    prev <- .libPaths()
    on.exit(.libPaths(prev))
    .libPaths(path)
    req <- c("R6", "curl", "docopt", "jsonlite", "pkgcache",
        "pkgdepends")
    if (!upgrade) {
        req <- missing_packages(req, path)
    }
    if (length(req) > 0) {
        prefix_message(img_boots(), 1, "conan is bootstrapping...",
            list(working = getwd(), target = path))
        install_packages(req, path, default_cran())
    }
    for (i in req) {
        loadNamespace(i, path)
    }
    invisible(path)
}
conan_install <- function (lib, packages, policy = "upgrade", repos = NULL, cran = NULL,
    path_bootstrap = NULL, path_cache = NULL)
{
    path_bootstrap <- conan_path_bootstrap(path_bootstrap)
    path_cache <- conan_path_cache(path_cache)
    conan_bootstrap(path_bootstrap)
    dir.create(lib, FALSE, TRUE)
    config <- list(library = lib)
    if (!is.null(path_cache)) {
        path_cache <- file.path(path_cache, "pkg")
        dir.create(path_cache, FALSE, TRUE)
        config$package_cache_dir <- path_cache
    }
    repos <- clean_repos(repos, cran)
    prefix_message(img_axe(), 2, "CONAN THE LIBRARIAN", list(Library = lib,
        Bootstrap = path_bootstrap, Cache = path_cache %||% "(unset)",
        Policy = policy, Repos = as.list(repos), Packages = as.list(packages)))
    prev <- .libPaths()
    .libPaths(c(lib, path_bootstrap))
    on.exit(.libPaths(prev), add = TRUE)
    oo <- options(repos = repos)
    on.exit(options(oo), add = TRUE)
    proposal <- conan_proposal(packages, config, policy)
    proposal$solve()
    proposal$stop_for_solution_error()
    proposal$download()
    proposal$stop_for_download_error()
    proposal$install()
}
conan_path <- function (path, var, fallback = tempfile("conan_"))
{
    if (!is.null(path)) {
        return(path)
    }
    path <- Sys.getenv(var, NA_character_)
    if (!is.na(path)) {
        return(path)
    }
    if (is.null(fallback)) {
        return(fallback)
    }
    path <- fallback
    names(fallback) <- var
    do.call(Sys.setenv, as.list(fallback))
    fallback
}
conan_path_bootstrap <- function (path)
{
    conan_path(path, "CONAN_PATH_BOOTSTRAP", tempfile("conan_"))
}
conan_path_cache <- function (path)
{
    conan_path(path, "CONAN_PATH_CACHE", NULL)
}
conan_proposal <- function (packages, config, policy)
{
    pkgdepends::new_pkg_installation_proposal(filter_packages(packages),
        config, policy = policy)
}
default_cran <- function (cran = NULL)
{
    cran %||% "https://cloud.r-project.org"
}
filter_packages <- function (packages)
{
    refs <- pkgdepends::parse_pkg_refs(packages)
    package_names <- vapply(refs, ref_to_package_name, "", USE.NAMES = FALSE)
    is_bare <- packages == package_names
    drop <- is_bare & (packages %in% package_names[!is_bare])
    packages[!drop]
}
img_axe <- function ()
{
    c("  ,:\\      /:.", " //  \\_()_/  \\\\", "||   |    |   ||",
        "||   |    |   ||", "||   |____|   ||", " \\\\  / || \\  //",
        "  `:/  ||  \\;'", "       ||", "       ||", "       XX",
        "       XX", "       XX", "       XX", "       OO", "       `'")
}
img_boots <- function ()
{
    c("     ._......", "     |X/.*| |", "     |X/+ | |", "     |X/* | |",
        "____/     ; ;", "\\_____/|_/_/")
}
install_packages <- function (packages, lib, repos)
{
    if (length(packages) == 0) {
        return()
    }
    utils::install.packages(packages, lib, repos)
    msg <- missing_packages(packages, lib)
    if (length(msg) > 0) {
        stop("Failed to install package: ", paste(sprintf("'%s'",
            msg), collapse = ", "))
    }
}
missing_packages <- function (packages, lib)
{
    setdiff(packages, .packages(TRUE, lib))
}
pad_right <- function (x)
{
    n <- nchar(x)
    paste0(x, strrep(" ", max(n) - n))
}
parse_main_conan <- function (args = commandArgs(TRUE), name = "conan")
{
    usage <- "Usage:\n%s <lib>"
    usage <- sprintf(usage, name)
    if (length(args) != 1 || grepl("^-", args)) {
        stop(usage, call. = FALSE)
    }
    list(lib = args)
}
prefix_message <- function (img, skip, title, data)
{
    for (line in prefix_message_build(img, skip, title, data)) {
        message(line)
    }
}
prefix_message_build <- function (img, skip, title, data)
{
    txt <- vector("list", length(data))
    lhs <- pad_right(paste0(names(data), ":"))
    i <- vapply(data, is.list, TRUE)
    if (any(i)) {
        txt[i] <- Map(c, trimws(lhs[i]), lapply(unname(data[i]),
            function(x) paste("  *", x)))
    }
    txt[!i] <- paste(lhs[!i], vapply(data[!i], identity, "",
        USE.NAMES = FALSE))
    txt <- unlist(c(list(title), txt))
    npad_vertical <- 1 + max(0, length(txt) + skip - length(img))
    ret <- pad_right(c(img, rep("", npad_vertical)))
    i <- seq_along(txt) + skip
    ret[i] <- paste(ret[i], txt, sep = "  ")
    ret <- trimws(ret, "right")
    ret
}
ref_to_package_name <- function (ref)
{
    if (ref$type == "local") {
        sub("(_.*)?\\.(tar.gz|tgz|zip)", "", basename(ref$path))
    }
    else {
        ref$package
    }
}
.dat <- parse_main_conan(name = "741e701d1d56dc1d468f99c88ad96931")
.packages <- "context"
.repos <- c(didehpc = "https://mrc-ide.github.io/didehpc-pkgs", CRAN = "https://cloud.r-project.org"
)
.policy <- "lazy"
.lib <- .dat$lib
conan_install(.lib, .packages, policy = .policy, repos = .repos)
